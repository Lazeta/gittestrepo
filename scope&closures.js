// lexical scope
// function outer() {
//   function inner() {
//     console.log(outerVar);
//   }
//   inner();
//   const outerVar = "Я снаружи!";
// }
// outer();
// 1. Инициализируем ссылку на функцию outer и вызываем в конце её же.
// 2. затем инициализируем переменную outerVar с аргументам "Я снаружи!"; получаем ссылку на функцию inner и после вызываем функцию inner.
// 3. попадаем в функцию inner и выполняем вывод переменной outerVar. Так как её нету в текущей блочной видимости, мы благодаря
// замыканию поднимаемся в глобальное окружение где у нас в scope есть ссылка на переменную outerVar.
// 4. выводим в консоль "Я снаружи!" и завершаем работу функции inner.

// Что будет, если объявить outerVar после inner()? Проверьте, как работает hoisting.
// мы получим ошибку ReferenceError: inner is not defined
// так как переменная outerVar объявлена после inner
// поэтому мы не можем получить доступ к outerVar внутри inner
// а если мы объявим outerVar до вызова inner, но после функции inner то так же мы получим поднятие переменной outerVar в глобальное окружение




// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//     setTimeout(function() {
//         console.log('Index: ' + i + ', element: ' + arr[i]);
//     }, 3000);
// }
// 1. Инициализация переменных : arr = [10, 12, 15, 21],
// "Переменная i объявлена в глобальной области видимости (благодаря var), инициализирована в цикле for (i = 0), и после завершения цикла сохраняет значение 4."
// 2. Цикл выполняется синхронно и мгновенно (за доли секунды). На каждой итерации:
//    1) Проверяется условие i < arr.length.
//    2) создаётся setTimeout с колбэком и задержкой 3000мс.
//    3) Важно: колбэк ещё не выполняется, он попадает в очередь макрозадач (Event Loop).
//    4) Постфиксный инкремент i++: После 4-й итерации i становится 4, и цикл завершается.
// 3. Завершение цикла. К моменту, когда колбэки setTimeout начнут выполняться (через 3 секунды):
//    1) i уже равна 4 (так как цикл давно завершился).
//    2) Все 4 колбэка видят одно и то же i = 4 (из-за области видимости var).
// 4. Выполнение колбэков setTimeout:
//    1) Каждый колбэк выводит: console.log('Index: ' + i + ', element: ' + arr[i]);
//    1.2) Где i = 4, arr[i] = undefined. Поэтому в консоли мы получим: Index: 4, element: undefined.
// Итого получим результат:
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// 5. в завершение добавлю: что Замыкание сохраняет ссылку на переменную i в глобальном окружении,
// но не её значение на момент создания, поэтому мы получим значение для i
// лишь после окончания цикла когда настанет очередь макрозадач.


// как отладить замыкание в предыдущем цикле?
// const arr = [10, 12, 15, 21];
// for (let i = 0; i < arr.length; i++) { // просто если возможно заменить var на let у меня будет блочная область
//   // видимости и i будет каждую итерацию будет сохранять своё значение для каждого вызова колбэка setTimeout
//     setTimeout(function() {
//         console.log('Index: ' + i + ', element: ' + arr[i]);
//     }, 3000);
// }


// или используем IIFE - Immediately Invoked Function Expression
// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//   (function (j) { // параметр j будет сохранять значение i на момент создания колбэка
//     setTimeout(function () {
//       console.log("Index: " + j + ", element: " + arr[j]); // j подставляем вместо i и получаем значение i на момент создания колбэка
//     }, 3000);
//   })(i); // аргументам передаём i
// }
// этот подход является legacy-кодом чтобы не пришлось уходить от var под который заточен код


// или для setTimeout используем третий аргумент в колбэке
// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//     setTimeout(function(j) {
//       console.log("Index: " + j + ", element: " + arr[j]);
//     }, 3000, i);
// }
// Так же суть что и IIFE




// что выводит этот код?
// var x = 10;
// function test() {
//     x = 20;
//     console.log(x);
// }
// test();
// console.log(x);
// инициализируем переменную x с глобальным scope и присваиваем ей значение 10.
// инициализируем функцию test
// вызываем функцию test
// внутри функции test мы меняем значение переменной x на 20 потому что она объявлена в глобальном scope и мы замыкаемся на ней.
// выводим в консоль значение x которое равно 20
// завершаем функцию и после мы выполняем второй console.log(x)
// выводим в консоль значение x которое равно 20 так же.




// var value = 0;
// function f() {
//     if (1) {          
//         value = true; 
//     } else {
//         value = false; 
//     }
//     console.log(value); 
// }
// f();
// console.log(value);
// инициализация value в глобальном scope со значением 0
// инициализация функции f
// вызываем функцию f
// Javascript приравнивает условия к булевому где 1 это truthy и 0 это falsy. 
// Поэтому у нас всегда выполняется часть кода if (true) { ...}
// value замыкается на глобальную переменную value и мы меняем значение 0 на true.
// else никогда не будет выполняться в текущем контексте кода.
// мы вне зависимости от того как наши условия были выполнены выполняем console.log(value)
// в консоль выводим true взяв значение из глобального scope
// функция завершается и мы выполняем второй console.log(value)
// выводим в консоль значение value = true
// Ответ: true true




// var y = 5;
// function update() {
//     y = 15;
// }
// console.log(y);
// update();
// console.log(y);
// Ответ: 5 15




// function b() {
//   function b() { // 10 завершаем функцию b с её результатом [Function: b]
//       var b = function() { // 5 объявляем переменную b как функцию с локальной областью видимости функции 
//           console.log('шарик находится'); // 7 выводим в консоль 'шарик находится'
//           console.log(b); // 8 выводим в консоль [Function: b]
//           b = 'под колпачком 3'; // 9 переприсваиваем локальную переменную b значение 'под колпачком 3' 
//       };
//       return b; // 6 Возвращает текущее значение локальной b ([Function: b])
//       // Важно:
//       // 1. Это происходит ДО перезаписи b = 'под колпачком 3' (которая случится при вызове функции)
//       // 2. Глобальная b не участвует — работаем только с локальной областью
//       // 3. return не вызывает функцию, а только возвращает ссылку на неё
//   }
//   b = b(); // 2 присваиваем глобальной переменной где храниться функция , саму себя, т.е. функцию = [Function: b]
//   console.log(b); // 3 выводим в консоль [Function: b]
//   b(); // 4 вызываем функцию 
//   console.log(b); // 11 выводим в консоль [Function: b]
//   b = 'под колпачком 2'; // 12 перезаписываем глобальную переменную b со значением 'под колпачком 2'
//   console.log(b); // 13 выводим в консоль 'под колпачком 2'
// }
// b(); // 1 вызов функции
// var b = 'под колпачком 1';
// Ответ: [Function: b] 'шарик находится' [Function: b] [Function: b] 'под колпачком 2'




// Замыкание - это функция способная запоминать свою внешнюю (лексическую) область видимости и сохранять доступ к переменным даже после того как функция завершила выполнение. 
// Как работает замыкание - когда функция создаётся в JS, то она захватывает переменные из scope, даже после завершения функции замыкание хранит ссылку на эти переменные.
// Зачем нам замыкания? Функциональное программирование (Currying & FP), Инкапсуляция данных (Data Encapsulation), Сохранение состояния (State Persistence), Обработка событий (Event Handlers).
// Инкапсуляция данных - мы скрываем переменные от внешнего кода, создавая приватные свойства.
// Функциональное программирование (Currying & FP) - Киррирование (преобразование функции от многих аргументов в цепочку функций от одного аргумента). Создание функций с предустановленными параметрами (частичное применение).
// Сохранение состояния (State Persistence) - позволяет функции помнить данные между вызовами без глобальных переменных.
// Обработка событий (Event Handlers)

// function outerFunction() {
//     let counter = 0;

//     function innerFunction() {
//         counter++;
//         return counter;
//     }

//     return innerFunction;
// }

// const newFunction = outerFunction();
// console.log(newFunction()); // 1
// мы получаем доступ лишь к значению переменной но не к самой переменной.




// использование замыкания с приватными переменными
// function createCounter() {
//     let _count = 0; // conditional privacy

//     return {
//         increment: function(amount) {
//             _count = _count + amount
//             return _count;
//         },
//         decrement: function(amount) {
//             _count = _count - amount;
//             return _count;
//         },
//         getCounter: function() {
//             return _count;
//         }
//     };
// }
// const counter = createCounter();
// console.log(counter.decrement(1));
// console.log(counter.increment(3));
// console.log(counter.getCounter());




// способы улучшить замыкание:
// 1)явный сброс ссылок : при помощи null
    // function createHeavyClosure() {
    //     const bigData = new Array(1000000).fill("Данные"); // Большие данные
    //     return () => {
    //         console.log(bigData.length);
    //     };
    // }

    // const closure = createHeavyClosure();
    // closure(); // Используем замыкание

    // Когда замыкание больше не нужно
    // closure = null; // сбрасываем ссылку, разрешая сборку мусора (GC)
// 2)использование WeakRef (слабая ссылка)
// 3)Избегание ненужных замыканий
// 4)Использование генераторов (function*).
    // function* counter() {
    //     let _count = 0;
    //     while (true) {
    //         yield _count++; // yield используют для приостановки выполнения функции и возврата значения
    //     }
    // }
    // const gen = counter();
    // console.log(gen.next().value); // 0
    // console.log(gen.next().value); // 1
// 5)Осторожность с DOM-элементами



// class Counter {
//     constructor(element) {
//         // слабая ссылка на какой-то элемент
//         this.ref = new WeakRef(element);
//         this.start()
//     }
// }




// const weakMap = new WeakMap();

// function createClosure() {
//   const key = {}; // Объект как ключ
//   const bigData = new Array(1000000).fill("Данные");

//   weakMap.set(key, bigData); // Слабая ссылка на bigData

//   return () => {
//     console.log(weakMap.get(key));
//   };
// }

// const closure = createClosure();
// closure();

// Когда key удаляется (например, выходит из scope), bigData тоже может быть собрана GC.




// function foo(){
//     var variable = 'global';

//     setTimeout(() => {
//         console.log(variable)
//     })
// };

// foo()