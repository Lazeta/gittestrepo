// lexical scope
// function outer() {
//   function inner() {
//     console.log(outerVar);
//   }
//   inner();
//   const outerVar = "Я снаружи!";
// }
// outer();
// 1. Инициализируем ссылку на функцию outer и вызываем в конце её же.
// 2. затем инициализируем переменную outerVar с аргументам "Я снаружи!"; получаем ссылку на функцию inner и после вызываем функцию inner.
// 3. попадаем в функцию inner и выполняем вывод переменной outerVar. Так как её нету в текущей блочной видимости, мы благодаря
// замыканию поднимаемся в глобальное окружение где у нас в scope есть ссылка на переменную outerVar.
// 4. выводим в консоль "Я снаружи!" и завершаем работу функции inner.

// Что будет, если объявить outerVar после inner()? Проверьте, как работает hoisting.
// мы получим ошибку ReferenceError: inner is not defined
// так как переменная outerVar объявлена после inner
// поэтому мы не можем получить доступ к outerVar внутри inner
// а если мы объявим outerVar до вызова inner, но после функции inner то так же мы получим поднятие переменной outerVar в глобальное окружение




// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//     setTimeout(function() {
//         console.log('Index: ' + i + ', element: ' + arr[i]);
//     }, 3000);
// }
// 1. Инициализация переменных : arr = [10, 12, 15, 21],
// "Переменная i объявлена в глобальной области видимости (благодаря var), инициализирована в цикле for (i = 0), и после завершения цикла сохраняет значение 4."
// 2. Цикл выполняется синхронно и мгновенно (за доли секунды). На каждой итерации:
//    1) Проверяется условие i < arr.length.
//    2) создаётся setTimeout с колбэком и задержкой 3000мс.
//    3) Важно: колбэк ещё не выполняется, он попадает в очередь макрозадач (Event Loop).
//    4) Постфиксный инкремент i++: После 4-й итерации i становится 4, и цикл завершается.
// 3. Завершение цикла. К моменту, когда колбэки setTimeout начнут выполняться (через 3 секунды):
//    1) i уже равна 4 (так как цикл давно завершился).
//    2) Все 4 колбэка видят одно и то же i = 4 (из-за области видимости var).
// 4. Выполнение колбэков setTimeout:
//    1) Каждый колбэк выводит: console.log('Index: ' + i + ', element: ' + arr[i]);
//    1.2) Где i = 4, arr[i] = undefined. Поэтому в консоли мы получим: Index: 4, element: undefined.
// Итого получим результат:
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// Index: 4, element: undefined.
// 5. в завершение добавлю: что Замыкание сохраняет ссылку на переменную i в глобальном окружении,
// но не её значение на момент создания, поэтому мы получим значение для i
// лишь после окончания цикла когда настанет очередь макрозадач.


// как отладить замыкание в предыдущем цикле?
// const arr = [10, 12, 15, 21];
// for (let i = 0; i < arr.length; i++) { // просто если возможно заменить var на let у меня будет блочная область
//   // видимости и i будет каждую итерацию будет сохранять своё значение для каждого вызова колбэка setTimeout
//     setTimeout(function() {
//         console.log('Index: ' + i + ', element: ' + arr[i]);
//     }, 3000);
// }


// или используем IIFE - Immediately Invoked Function Expression
// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//   (function (j) { // параметр j будет сохранять значение i на момент создания колбэка
//     setTimeout(function () {
//       console.log("Index: " + j + ", element: " + arr[j]); // j подставляем вместо i и получаем значение i на момент создания колбэка
//     }, 3000);
//   })(i); // аргументам передаём i
// }
// этот подход является legacy-кодом чтобы не пришлось уходить от var под который заточен код


// или для setTimeout используем третий аргумент в колбэке
// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//     setTimeout(function(j) {
//       console.log("Index: " + j + ", element: " + arr[j]);
//     }, 3000, i);
// }
// Так же суть что и IIFE




// что выводит этот код?
// var x = 10;
// function test() {
//     x = 20;
//     console.log(x);
// }
// test();
// console.log(x);
// инициализируем переменную x с глобальным scope и присваиваем ей значение 10.
// инициализируем функцию test
// вызываем функцию test
// внутри функции test мы меняем значение переменной x на 20 потому что она объявлена в глобальном scope и мы замыкаемся на ней.
// выводим в консоль значение x которое равно 20
// завершаем функцию и после мы выполняем второй console.log(x)
// выводим в консоль значение x которое равно 20 так же.




// var value = 0;
// function f() {
//     if (1) {          
//         value = true; 
//     } else {
//         value = false; 
//     }
//     console.log(value); 
// }
// f();
// console.log(value);
// инициализация value в глобальном scope со значением 0
// инициализация функции f
// вызываем функцию f
// Javascript приравнивает условия к булевому где 1 это truthy и 0 это falsy. 
// Поэтому у нас всегда выполняется часть кода if (true) { ...}
// value замыкается на глобальную переменную value и мы меняем значение 0 на true.
// else никогда не будет выполняться в текущем контексте кода.
// мы вне зависимости от того как наши условия были выполнены выполняем console.log(value)
// в консоль выводим true взяв значение из глобального scope
// функция завершается и мы выполняем второй console.log(value)
// выводим в консоль значение value = true
// Ответ: true true




// var y = 5;
// function update() {
//     y = 15;
// }
// console.log(y);
// update();
// console.log(y);
// Ответ: 5 15




// function b() {
//   function b() { // 10 завершаем функцию b с её результатом [Function: b]
//       var b = function() { // 5 объявляем переменную b как функцию с локальной областью видимости функции 
//           console.log('шарик находится'); // 7 выводим в консоль 'шарик находится'
//           console.log(b); // 8 выводим в консоль [Function: b]
//           b = 'под колпачком 3'; // 9 переприсваиваем локальную переменную b значение 'под колпачком 3' 
//       };
//       return b; // 6 Возвращает текущее значение локальной b ([Function: b])
//       // Важно:
//       // 1. Это происходит ДО перезаписи b = 'под колпачком 3' (которая случится при вызове функции)
//       // 2. Глобальная b не участвует — работаем только с локальной областью
//       // 3. return не вызывает функцию, а только возвращает ссылку на неё
//   }
//   b = b(); // 2 присваиваем глобальной переменной где храниться функция , саму себя, т.е. функцию = [Function: b]
//   console.log(b); // 3 выводим в консоль [Function: b]
//   b(); // 4 вызываем функцию 
//   console.log(b); // 11 выводим в консоль [Function: b]
//   b = 'под колпачком 2'; // 12 перезаписываем глобальную переменную b со значением 'под колпачком 2'
//   console.log(b); // 13 выводим в консоль 'под колпачком 2'
// }
// b(); // 1 вызов функции
// var b = 'под колпачком 1';
// Ответ: [Function: b] 'шарик находится' [Function: b] [Function: b] 'под колпачком 2'